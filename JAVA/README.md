# 자바의 정석

자바가 C++을 참고해서 만들어졌다는 점을 새롭게 알게되었다.

최근에 알고리즘을 공부하면서 C++에 생각보다 기능이 되게 많아서 시간이 지나면서 업데이트 된건가 했는데 C++이 오히려 원조였다 ㅋㅋㅋ

## Java 언어의 특징

1. 운영체제에 독립적

2. 객체지향언어

3. 비교적 배우기 쉽다.

   C++과 스몰톡이라는 객체지향언어의 장점은 취하면서 복잡하고 불필요한 부분을 제거하였다.

4. 자동 메모리 관리 - 가비지컬렉터

5. 네트워크, 분산처리 지원

   다양한 네트워크 프로그래밍 라이브러리 지원

6. 멀티쓰레드 지원

   일반적인 방식과 달리 시스템과 관계없이 구현 가능

7. 동적 로딩 지원

   애플리케이션의 변경사항이 발생해도 비교 적은 작업만으로 처리 가능

## JVM

Java virtual machine

장점: 운영체제에 관계없이 실행이 가능하다. `Write once, run anywhere.`

JVM은 운영체제에 종속적이라 다양한 OS용 JVM이 존재한다.

단점: 실행시에 해석이 되고 JVM을 한번 거쳐서 실행되기 때문에 속도가 느리다. 하지만 JIT컴파일러와 향상된 최적화 기술을 통해 지금은 속도의 격차가 많이 줄었다.

## path

그동안 사용한적도 있고 어렴풋이 알고 있었지만 이번에 정확하게 알게되었다.

```
path는 OS가 파일의 위치(디렉토리)를 파악하는데 사용하는 경로(path)로, path에 디렉토리를 등록하면, 해당 디렉토리에 포함된 파일을 파일 경로없이 파일 이름만으로도 사용할 수 있게 된다.
```

## Hello.java

### 클래스

자바에서 모든 코드는 반드시 클래스 안에 존재해야 한다.

이때 소스파일의 이름은 클래스의 이름과 일치해야 한다.

하나의 소스파일에 하나의 클래스가 있는것이 일반적이지만 2개 이상의 클래스가 있는 경우 public 클래스의 이름과 일치해야 하고, public 클래스가 없는 경우 어떤 클래스의 이름으로 해도 상관없다. 그리고 한 소스파일에 public 클래스는 하나만 존재한다.

소스파일과 달리 클래스파일은 클래스마다 하나씩 만들어진다.

클래스가 main 메서드를 반드시 가질 필요는 없지만 main 메서드는 java 애플리케이션의 시작점이므로 하나의 java 앱은 main 메서드를 포함한 클래스가 반드시 하나 있어야 한다.

### 실행과정

1. 필요한 클래스 로드
2. 클래스 파일 검사
3. 지정된 클래스에서 main 메서드 호출

### println()

print line

```java
System.out.println("x: "+10);
```

파이썬처럼 덧셈연산자를 이용해서 문자열을 합칠 수 있다.

### printf()

`println()`은 출력 형식을 따로 지정할 수 없다.

`printf()`는 지시자(specifier)를 통해 출력 형식을 지정해 줄 수 있다.

```java
// 정수형
System.out.printf("%5d", 10);
System.out.printf("%-5d", 10);
System.out.printf("%05d", 10);
// 16진수
System.out.printf("%x", 10);
System.out.printf("%#x", 10);
System.out.printf("%#X", 10);
// 2진수. 따로 지시자가 없기 때문에 문자열로 변환하는 메서드 이용
System.out.printf("%s", Integer.toBinaryString(10));

// 실수형
System.out.printf(".10f%n", 3.1452);
System.out.printf("14.10f%n", 3.1452);  //소수점 아래 10자리, 소수점 포함 4자리
System.out.printf("014.10f%n", 3.1452);

// 문자열
System.out.printf("%20s", "fejaklgjelkaw");
System.out.printf("%-20s", "fejaklgjelkaw");
System.out.printf("%.8s", "fejaklgjelkaw");
```

c언어와 대체로 비슷하지만 줄바꿈문자로 `%n`을 사용한다.

(`\n`을 사용할 수 있지만 OS마다 줄바꿈문자가 다를 수 있기 때문에 `%n`을 사용하는 것이 안전하다고 한다.)

문자열도 형식지정자를 사용할 수 있다.

실수형을 출력할때 소수점 자리수를 설정하면 반올림되어서 표시된다.

### 입력 - Scanner

```java
import java.util.*;

Scanner scanner = new Scanner(System.in);
String input = scanner.nextLine();	// Enter를 누르기 전까지 문자열로 입력받는다
int num = Integer.parseInt(input);
```

`nextInt()`나 `nextFloat()`와 같은 메서드들을 사용하면 변환하지 않고 바로 받을 수 있지만 연속적으로 값을 입력받기 까다롭기 때문에 `nextLine()`으로 입력받고 적절하게 변환해서 사용하는 것이 더 편하다.

### 

## 변수

### 1. 기본형

실제 값 저장, 총 8개

#### 논리형

`boolean`(1byte)

> 기본값: false
>
> 1bit로도 충분하지만 java에서 데이터를 다루는 최소단위가 1byte라 1byte의 크기를 갖는다.
>
> c++과는 달리 형변환을 지원하지 않는다.
>
> ```
> while(1)  // 불가.
> while(true)  // OK.
> ```

#### 문자형

`char`(2byte)

#### 정수형

`byte`(이진 데이터를 다룰때 사용, 1byte), `short`(C언어와의 호환을 위해 추가됨, 2byte)

> JVM의 피연산자 스택이 피연산자를 4byte 단위로 저장하기 때문에 계산시 4byte로 변환되어서 사용된다. 성능보다 저장공간을 절약하는 것이 더 중요할 때 사용

`int`(기본자료형, 4byte), `long`(8byte)

> 대부분의 경우 `int`를 사용하는 것이 효율적이다.
>
> int의 범위(약 +-20억)를 넘어가는 값을 다룰때 `long` 사용.
>
> long의 범위를 넘어가는 값을 다룬다면 `실수형`이나 `Biginteger 클래스` 사용.

> [c언어에서 int와 long의 차이](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=passith&logNo=70152718749)
> int는 CPU가 가장 효율적으로 다룰 수 있는 정수형으로 운영체제에 따라 32bit또는 64bit의 크기를 가지는데
> long은 크기가 4byte로 고정되어있다.

#### 값의범위

-2^(n-1)부터 2^(n-1)-1까지

2^10 = 1024, 10^3 = 1000으로 근사시켜서 값의 대략적인 범위를 짐작할 수 있다.

```
ex) int형의 범위: -2^31 ~ 2^31-1 대략적으로 2*10^9 정도의 음수/양수까지 표현할 수 있다.
```

#### 실수형

`float`(4byte, 정밀도 7자리. 소수점 이하 6자리), `double`(기본자료형, 8byte, 정밀도 15자리)

부동소수점(floating-point) 방식

`부호`, `지수`, `가수` 3부분으로 이루어진다.

또한 값의 범위 뿐만 아니라 정밀도도 중요하다.

`지수`에서 최소값, 최대값은 특별한 값을 위해 사용된다.

- NaN(Not a Number)
- 무한대(POSITIVE_INFINITY, NEGATIVE_INFINITY)

`지수` 부분에는 따로 부호 비트가 없기때문에 `bias 표현법`을 사용한다.

### 2. 참조형

* `null`또는 객체의 주소를 값으로 갖는다.
* C언어와 달리 참조형 변수간의 연산을 할 수 없다

```java
// 참조변수 초기화
Date today = new Date()
```

### 3. 상수

java에서 상수는 `final`를 앞에 붙여서 사용한다.

```java
final int MAX_SPEED = 10;
```

### 4. 리터럴

정확한 정의는 모르고 있었는데 프로그래밍에서 상수가 다른 의미로 사용되면서 우리가 일반적으로 사용하는 상수를 리터럴이라고 부르는 것이었다.

```
리터럴
: 그 자체로 값을 의미하는 것.

상수
: 값을 한번만 저장할 수 있는 공간. 보통 리터럴에 의미있는 이름을 붙여서 사용하기 위해 쓰인다.
-> 코드의 이해와 수정이 간편해진다.
```

#### 접미사

접미사를 사용해 자료형을 특정할 수 있다. 접미사를 사용하지 않는다면 기본자료형인 int와 double로 취급된다.

* `l, L` : long 타입 리터럴 (l은 숫자 1과 헷갈릴 우려가 있어 보통 L을 주로 사용한다.)
* `F, f `: float 타입 리터럴
* `0x, 0X` : 16진수 
* `0` : 8진수

```
float pi = 3.14;  // 오류. float 타입 변수에 double 타입 리터럴을 저장하기 떄문
float pi = 3.14f;  // OK.
double pid = 3.14f;  // OK.
```

c언어나 다른 언어에서는 자동으로 형 변환이 이루어지는걸로 아는데 java는 아예 오류가 나기 때문에 더 유의해야 할 것 같다. (변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우 형변환을 생략하면 오류가 발생한다.)

java에서도 저장범위가 넓은 타입에 좁은 타입의 값을 저장하는 것은 허용된다.

float 형을 사용하는 경우만 주의해서 사용하면 될 것 같다.

\+ 변수의 범위 고려

#### 실수형 리터럴

- 10의 제곱을 나타내는 기호 `E, e`

  `3.14e3` == 3140.0

  `1e-3` == 0.001

* 기호p - 16진수 * 2의 제곱

  `0x1p2` == (1*16^0) * 2^2 == 1.0 * 4 == 4.0

#### 문자, 문자열 리터럴

빈 문자열 허용 ""

빈 문자 불가 ''

문자열 덧셈 연산자 지원

숫자를 문자열로 변환할때 빈문자열과 덧셈 연산자를 수행해서 쉽게 변환할 수 있다.

```java
String str = "Java" + 8.0;	// "Java8.0"
String num = 17 + ""	// "17"
```

### 진법

에니악은 10진법을 사용했다는것을 처음 알았다. 하지만 전압을 10단계로 나누어 처리하는데 한계가 있어 에드박은 2진법을 사용해서 만들었다.

`word`: CPU가 한 번에 처리할 수 있는 데이터의 크기.

int형의 크기와 워드의 크기가 동일한 것 같아서 찾아봤는데 int와 word는 동일하지 않다. https://kldp.org/node/138360

`정수의 진법변환` 나눠서 변환(결과값 - 나머지)

`실수의 진법변환` 곱해서 변환(결과값 - 정수부)

###  2의 보수

어떤 수의 `n의 보수`는 더했을때 n이 되는 수

`2의 보수 관계` 역시 더했을 때 2가 되는 두 수의 관계를 말하며 2는 이진수로 10이다.

2진수로 10은 자리올림이 발생하고 0이 되는 수를 말한다.

따라서 2의 보수관계에 있는 두 수를 더하면 0이 된다.

이를 이용해서 대부분의 시스템들이 부호있는 정수를 `2의 보수법`으로 표현한다. 

어떤 수의 `1의 보수 + 1`은 `2의 보수`이다. 왜냐하면 자리올림이 발생하지만 오버플로우가 발생하면서 0이 되기 때문.

### 오버플로우

최대값 + 1 -> 최소값

최소값 - 1 -> 최대값

#### 부호없는 정수

2진수로 0이 될때 오버플로우 발생.

```java
1111  // 15
0000  // 0
```

#### 부호있는 정수

부호비트가 0에서 1이 될때 오버플로우가 발생.

```java
0111  // 7
1000  // -8
```

## 연산자

대입 연산자의 반환값은 저장된 값.

### 산술변환

1. 두 피연산자의 타입을 둘 중 큰 타입으로 일치시킨다.

2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환한다.

   (int가 가장 효율적으로 처리할 수 있고 오버플로우를 방지하기 위해서)

```java
char c1 = 'a';

char c2 = c1++;  // OK.
char c3 = c1 + 1;  // 오류.
char c4 = (char)(c1 + 1);  // OK.
char c5 = 'a' + 1;  // OK.
// 리터럴 간의 연산은 실행과정 동안 변하는 값이 아니기 때문에 컴파일 시 컴파일러가 계산해서 그 결과로 대체한다.
```

### 문자열 비교

```java
String s1 = new String("abc");
String s2 = "abc";  // 객체 중 String만 new를 사용하지 않고 간단하게 객체생성 가능
String s3 = "Abc";

System.out.println(s1 == s2);  // false. 객체 자체를 비교.
System.out.println(s1.equals(s2));  // true. 문자열의 내용을 비교.
System.out.println(s1.equalsIgnoreCase(s2));  // 대소문자 구별없이 비교.
```

### 논리 연산자

OR연산의 경우 한쪽만 참이면 참이므로 좌측 피연산자가 참이면 우측 피연산자는 평가하지 않는다. 마찬가지로 AND연산의 경우 한쪽만 거짓이면 거짓이므로 좌측 피연산자가 거짓이면 우측 피연산자는 평가하지 않는다.

따라서 우측 피연산자를 잘 설정하면 연산 속도를 높일 수 있다.

#### 논리 부정 연산자

논리부정연산자 `!`를 적절히 사용해서 더 직관적인 조건식을 만들 수 있다.

```java
// 알파벳 소문자가 아닌 경우를 찾는 식
ch < 'a' || ch > 'z'
// 논리 부정 연산자를 이용하면 더 직관적이다.
!('a' <= ch || ch <= 'z')
```

###  비트 연산자

비트OR연산자 `|`는 주로 특정 비트의 값을 변경할 때 사용한다.

```java
0xAB | 0xF = 0xAF
```

비트AND연산자 `&`는 주로 특정 비트의 값을 뽑아낼 때 사용한다.

```java
0xAB & 0xF = 0xB
```

비트XOR연산자 `^`는 같은 값을 두고 XOR연산을 수행하면 원래의 값으로 돌아오는 특징을 이용해서 간단한 암호화에 사용된다.

```java
0xAB ^ 0xF = 0xA4
0xA4 ^ 0xF = 0xAB
```

### 쉬프트 연산자

```java
x << n  // x*2^n
x >> n  // x/2^n
```

쉬프트연산자와 &연산자를 이용해서 16진수를 끝에서부터 한짜리 뽑아내는 예제

```java
0xABCD & 0x000F == 0x000D  // D
0xABCD >> 4 == 0x0ABC
0x0ABC & 0x000F == 0x000C  // C
0x0ABC >> 4 == 0x00AB
0x00AB & 0x000F == 0x000B  // B
0x00AB >> 4 == 0x000A
0x000A & 0x000F == 0x000A  // A
```

### 삼항연산자

`조건식` ? `식1` : `식2`

참이면 `식1` return, 거짓이면 `식2` return

