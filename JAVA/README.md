# 자바의 정석

자바가 C++을 참고해서 만들어졌다는 점을 새롭게 알게되었다.

최근에 알고리즘을 공부하면서 C++에 생각보다 기능이 되게 많아서 시간이 지나면서 업데이트 된건가 했는데 C++이 오히려 원조였다

## 자바의 역사

가전제품에 탑재될 소프트웨어 제작

-> C++ 사용 -> 부족함을 느낌

-> C++을 보완한 새로운 언어 개발 (Oak)

-> 인터넷의 등장 -> 운영체제에 독립적인 Oak가 이에 적합하다고 판단

-> 인터넷쪽으로 개발방향을 바꾸고 이름을 Java로 변경

인터넷 상에서 사운드와 애니메이션 등의 요소를 사용하기 위해선 자바로 작성된 애플릿을 사용해야 했기 때문에 큰 인기를 끌었다.

하지만 현재는 보안상의 이유로 애플릿은 더 이상 지원되지 않고 서버 쪽 프로그래밍과 안드로이드에서 주로 사용되고 있다.

## Java 언어의 특징

1. 운영체제에 독립적

2. 객체지향언어

3. 비교적 배우기 쉽다.

   C++과 스몰톡이라는 객체지향언어의 장점은 취하면서 복잡하고 불필요한 부분을 제거하였다.

4. 자동 메모리 관리 - 가비지컬렉터

5. 네트워크, 분산처리 지원

   다양한 네트워크 프로그래밍 라이브러리 지원

6. 멀티쓰레드 지원

   일반적인 방식과 달리 시스템과 관계없이 구현 가능

7. 동적 로딩 지원

   애플리케이션의 변경사항이 발생해도 비교 적은 작업만으로 처리 가능

## JVM

Java virtual machine

장점: 운영체제에 관계없이 실행이 가능하다. `Write once, run anywhere.`

JVM은 운영체제에 종속적이라 다양한 OS용 JVM이 존재한다.

단점: 실행시에 해석이 되고 JVM을 한번 거쳐서 실행되기 때문에 속도가 느리다. 하지만 JIT컴파일러와 향상된 최적화 기술을 통해 지금은 속도의 격차가 많이 줄었다.

## path

그동안 사용한적도 있고 어렴풋이 알고 있었지만 이번에 정확하게 알게되었다.

```
path는 OS가 파일의 위치(디렉토리)를 파악하는데 사용하는 경로(path)로, path에 디렉토리를 등록하면, 해당 디렉토리에 포함된 파일을 파일 경로없이 파일 이름만으로도 사용할 수 있게 된다.
```

## Hello.java

### 클래스

자바에서 모든 코드는 반드시 클래스 안에 존재해야 한다.

이때 소스파일의 이름은 클래스의 이름과 일치해야 한다.

하나의 소스파일에 하나의 클래스가 있는것이 일반적이지만 2개 이상의 클래스가 있는 경우 public 클래스의 이름과 일치해야 하고, public 클래스가 없는 경우 어떤 클래스의 이름으로 해도 상관없다. 그리고 한 소스파일에 public 클래스는 하나만 존재한다.

소스파일과 달리 클래스파일은 클래스마다 하나씩 만들어진다.

클래스가 main 메서드를 반드시 가질 필요는 없지만 main 메서드는 java 애플리케이션의 시작점이므로 하나의 java 앱은 main 메서드를 포함한 클래스가 반드시 하나 있어야 한다.

### 실행과정

1. 필요한 클래스 로드
2. 클래스 파일 검사
3. 지정된 클래스에서 main 메서드 호출

### println()

print line

```java
System.out.println("x: "+10);
```

파이썬처럼 덧셈연산자를 이용해서 문자열을 합칠 수 있다.

### printf()

`println()`은 출력 형식을 따로 지정할 수 없다.

`printf()`는 지시자(specifier)를 통해 출력 형식을 지정해 줄 수 있다.

```java
// 정수형
System.out.printf("%5d", 10);
System.out.printf("%-5d", 10);
System.out.printf("%05d", 10);
// 16진수
System.out.printf("%x", 10);
System.out.printf("%#x", 10);
System.out.printf("%#X", 10);
// 2진수. 따로 지시자가 없기 때문에 문자열로 변환하는 메서드 이용
System.out.printf("%s", Integer.toBinaryString(10));

// 실수형
System.out.printf(".10f%n", 3.1452);
System.out.printf("14.10f%n", 3.1452);  //소수점 아래 10자리, 소수점 포함 4자리
System.out.printf("014.10f%n", 3.1452);

// 문자열
System.out.printf("%20s", "fejaklgjelkaw");
System.out.printf("%-20s", "fejaklgjelkaw");
System.out.printf("%.8s", "fejaklgjelkaw");
```

c언어와 대체로 비슷하지만 줄바꿈문자로 `%n`을 사용한다.

(`\n`을 사용할 수 있지만 OS마다 줄바꿈문자가 다를 수 있기 때문에 `%n`을 사용하는 것이 안전하다고 한다.)

문자열도 형식지정자를 사용할 수 있다.

실수형을 출력할때 소수점 자리수를 설정하면 반올림되어서 표시된다.

### 입력 - Scanner

```java
import java.util.*;

Scanner scanner = new Scanner(System.in);
String input = scanner.nextLine();	// Enter를 누르기 전까지 문자열로 입력받는다
int num = Integer.parseInt(input);
```

`nextInt()`나 `nextFloat()`와 같은 메서드들을 사용하면 변환하지 않고 바로 받을 수 있지만 연속적으로 값을 입력받기 까다롭기 때문에 `nextLine()`으로 입력받고 적절하게 변환해서 사용하는 것이 더 편하다.

### 입력 - 커맨드 라인 이용

터미널에서 프로그램을 실행할 때 클래스 이름 뒤에 공백문자로 구분하여 여러 개의 문자열을 프로그램에 전달할 수 있다. 공백이 있는 문자열은 큰 따옴표로 묶어서 입력한다.

전달된 문자열은 main 메서드의 args 매개변수에 전달된다.

## 변수

### 1. 기본형

실제 값 저장, 총 8개

#### 논리형

`boolean`(1byte)

> 기본값: false
>
> 1bit로도 충분하지만 java에서 데이터를 다루는 최소단위가 1byte라 1byte의 크기를 갖는다.
>
> c++과는 달리 형변환을 지원하지 않는다.
>
> ```
> while(1)  // 불가.
> while(true)  // OK.
> ```

#### 문자형

`char`(2byte)

#### 정수형

`byte`(이진 데이터를 다룰때 사용, 1byte), `short`(C언어와의 호환을 위해 추가됨, 2byte)

> JVM의 피연산자 스택이 피연산자를 4byte 단위로 저장하기 때문에 계산시 4byte로 변환되어서 사용된다. 성능보다 저장공간을 절약하는 것이 더 중요할 때 사용

`int`(기본자료형, 4byte), `long`(8byte)

> 대부분의 경우 `int`를 사용하는 것이 효율적이다.
>
> int의 범위(약 +-20억)를 넘어가는 값을 다룰때 `long` 사용.
>
> long의 범위를 넘어가는 값을 다룬다면 `실수형`이나 `Biginteger 클래스` 사용.

> [c언어에서 int와 long의 차이](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=passith&logNo=70152718749)
> int는 CPU가 가장 효율적으로 다룰 수 있는 정수형으로 운영체제에 따라 32bit또는 64bit의 크기를 가지는데
> long은 크기가 4byte로 고정되어있다.

#### 값의범위

-2^(n-1)부터 2^(n-1)-1까지

2^10 = 1024, 10^3 = 1000으로 근사시켜서 값의 대략적인 범위를 짐작할 수 있다.

```
ex) int형의 범위: -2^31 ~ 2^31-1 대략적으로 2*10^9 정도의 음수/양수까지 표현할 수 있다.
```

#### 실수형

`float`(4byte, 정밀도 7자리. 소수점 이하 6자리), `double`(기본자료형, 8byte, 정밀도 15자리)

부동소수점(floating-point) 방식

`부호`, `지수`, `가수` 3부분으로 이루어진다.

또한 값의 범위 뿐만 아니라 정밀도도 중요하다.

`지수`에서 최소값, 최대값은 특별한 값을 위해 사용된다.

- NaN(Not a Number)
- 무한대(POSITIVE_INFINITY, NEGATIVE_INFINITY)

`지수` 부분에는 따로 부호 비트가 없기때문에 `bias 표현법`을 사용한다.

### 2. 참조형

* `null`또는 객체의 주소를 값으로 갖는다.
* C언어와 달리 참조형 변수간의 연산을 할 수 없다.

```java
// 참조변수 초기화
Date today = new Date()
```

### 3. 상수

java에서 상수는 `final`를 앞에 붙여서 사용한다.

```java
final int MAX_SPEED = 10;
```

### 4. 리터럴

정확한 정의는 모르고 있었는데 프로그래밍에서 상수가 다른 의미로 사용되면서 우리가 일반적으로 사용하는 상수를 리터럴이라고 부르는 것이었다.

```
리터럴: 그 자체로 값을 의미하는 것.상수: 값을 한번만 저장할 수 있는 공간. 보통 리터럴에 의미있는 이름을 붙여서 사용하기 위해 쓰인다.-> 코드의 이해와 수정이 간편해진다.
```

#### 접미사

접미사를 사용해 자료형을 특정할 수 있다. 접미사를 사용하지 않는다면 기본자료형인 int와 double로 취급된다.

* `l, L` : long 타입 리터럴 (l은 숫자 1과 헷갈릴 우려가 있어 보통 L을 주로 사용한다.)
* `F, f `: float 타입 리터럴
* `0x, 0X` : 16진수 
* `0` : 8진수

```
float pi = 3.14;  // 오류. float 타입 변수에 double 타입 리터럴을 저장하기 떄문float pi = 3.14f;  // OK.double pid = 3.14f;  // OK.
```

c언어나 다른 언어에서는 자동으로 형 변환이 이루어지는걸로 아는데 java는 아예 오류가 나기 때문에 더 유의해야 할 것 같다. (변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우 형변환을 생략하면 오류가 발생한다.)

java에서도 저장범위가 넓은 타입에 좁은 타입의 값을 저장하는 것은 허용된다.

float 형을 사용하는 경우만 주의해서 사용하면 될 것 같다.

\+ 변수의 범위 고려

#### 실수형 리터럴

- 10의 제곱을 나타내는 기호 `E, e`

  `3.14e3` == 3140.0

  `1e-3` == 0.001

* 기호p - 16진수 * 2의 제곱

  `0x1p2` == (1*16^0) * 2^2 == 1.0 * 4 == 4.0

#### 문자, 문자열 리터럴

빈 문자열 허용 ""

빈 문자 불가 ''

문자열 덧셈 연산자 지원

숫자를 문자열로 변환할때 빈문자열과 덧셈 연산자를 수행해서 쉽게 변환할 수 있다.

```java
String str = "Java" + 8.0;	// "Java8.0"String num = 17 + ""	// "17"
```

### 진법

에니악은 10진법을 사용했다는것을 처음 알았다. 하지만 전압을 10단계로 나누어 처리하는데 한계가 있어 에드박은 2진법을 사용해서 만들었다.

`word`: CPU가 한 번에 처리할 수 있는 데이터의 크기.

int형의 크기와 워드의 크기가 동일한 것 같아서 찾아봤는데 int와 word는 동일하지 않다. https://kldp.org/node/138360

`정수의 진법변환` 나눠서 변환(결과값 - 나머지)

`실수의 진법변환` 곱해서 변환(결과값 - 정수부)

###  2의 보수

어떤 수의 `n의 보수`는 더했을때 n이 되는 수

`2의 보수 관계` 역시 더했을 때 2가 되는 두 수의 관계를 말하며 2는 이진수로 10이다.

2진수로 10은 자리올림이 발생하고 0이 되는 수를 말한다.

따라서 2의 보수관계에 있는 두 수를 더하면 0이 된다.

이를 이용해서 대부분의 시스템들이 부호있는 정수를 `2의 보수법`으로 표현한다. 

어떤 수의 `1의 보수 + 1`은 `2의 보수`이다. 왜냐하면 자리올림이 발생하지만 오버플로우가 발생하면서 0이 되기 때문.

### 오버플로우

최대값 + 1 -> 최소값

최소값 - 1 -> 최대값

#### 부호없는 정수

2진수로 0이 될때 오버플로우 발생.

```java
1111  // 150000  // 0
```

#### 부호있는 정수

부호비트가 0에서 1이 될때 오버플로우가 발생.

```java
0111  // 71000  // -8
```

## 연산자

대입 연산자의 반환값은 저장된 값.

### 산술변환

1. 두 피연산자의 타입을 둘 중 큰 타입으로 일치시킨다.

2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환한다.

   (int가 가장 효율적으로 처리할 수 있고 오버플로우를 방지하기 위해서)

```java
char c1 = 'a';char c2 = c1++;  // OK.char c3 = c1 + 1;  // 오류.char c4 = (char)(c1 + 1);  // OK.char c5 = 'a' + 1;  // OK.// 리터럴 간의 연산은 실행과정 동안 변하는 값이 아니기 때문에 컴파일 시 컴파일러가 계산해서 그 결과로 대체한다.
```

### 논리 연산자

OR연산의 경우 한쪽만 참이면 참이므로 좌측 피연산자가 참이면 우측 피연산자는 평가하지 않는다. 마찬가지로 AND연산의 경우 한쪽만 거짓이면 거짓이므로 좌측 피연산자가 거짓이면 우측 피연산자는 평가하지 않는다.

따라서 우측 피연산자를 잘 설정하면 연산 속도를 높일 수 있다.

#### 논리 부정 연산자

논리부정연산자 `!`를 적절히 사용해서 더 직관적인 조건식을 만들 수 있다.

```java
// 알파벳 소문자가 아닌 경우를 찾는 식ch < 'a' || ch > 'z'// 논리 부정 연산자를 이용하면 더 직관적이다.!('a' <= ch || ch <= 'z')
```

###  비트 연산자

비트OR연산자 `|`는 주로 특정 비트의 값을 변경할 때 사용한다.

```java
0xAB | 0xF = 0xAF
```

비트AND연산자 `&`는 주로 특정 비트의 값을 뽑아낼 때 사용한다.

```java
0xAB & 0xF = 0xB
```

비트XOR연산자 `^`는 같은 값을 두고 XOR연산을 수행하면 원래의 값으로 돌아오는 특징을 이용해서 간단한 암호화에 사용된다.

```java
0xAB ^ 0xF = 0xA40xA4 ^ 0xF = 0xAB
```

### 쉬프트 연산자

```java
x << n  // x*2^nx >> n  // x/2^n
```

쉬프트연산자와 &연산자를 이용해서 16진수를 끝에서부터 한짜리 뽑아내는 예제

```java
0xABCD & 0x000F == 0x000D  // D0xABCD >> 4 == 0x0ABC0x0ABC & 0x000F == 0x000C  // C0x0ABC >> 4 == 0x00AB0x00AB & 0x000F == 0x000B  // B0x00AB >> 4 == 0x000A0x000A & 0x000F == 0x000A  // A
```

### 삼항연산자

`조건식` ? `식1` : `식2`

참이면 `식1` return, 거짓이면 `식2` return

skstn

### 난수

`Math.random()` 사용.

0.0~1.0 사이의 double형 실수 반환. (1.0은 범위에 포함되지 않는다.)

## 반복문

### 향상된 for문

배열이나 컬렉션에 저장된 요소에 접근할 떄 기존보다 편리한 방법으로 처리할 수 있다.

```java
int arr[] = {10,20,30,40,50};for(int a : arr) {    System.out.println(a);}
```

c++에서 `for (auto& s : S)`랑 비슷하다.

하지만 c++과는 다르게 자로형도 직접 지정해줘야 하고 값을 변경하는 것은 가능하지 않다.

[BOJ 2577 숫자의 개수](https://www.acmicpc.net/problem/2577)

### 이름 붙은 반복문

break, continue문은 근접한 단 하나의 반복문만 벗어날 수 있기 때문에 반복문에 이름을 붙이고 break문과 continue문에 이름을 지정하고 사용해서 둘 이상의 반복문을 벗어날 수 있다.

```java
Loop1 : while(true) {    while(true) {        break Loop1;    }}
```

## 배열

```java
// 배열의 생성, 초기화int[] arr = new int[5];  // OK.int arr[] = new int[5];  // OK.int[] arr = new int[]{ 10, 20, 30 };  // OK.int[] arr = { 10, 20, 30 };  // OK.// 생성과 동시에 초기화를 하는 경우에만 new int[] 부분을 생략할 수 있다.int[] arr;arr = new int[]{ 10, 20, 30 };  // OK.arr = { 10, 20, 30 };  // Error.
```

각 배열요소는 기본값 0을 갖는다.



유효한 범위를 벗어난 값을 index로 사용했을때 컴파일에서 오류가 나지 않고 실행 시 오류가 나는 이유

> 배열의 index로 변수를 많이 사용하는데, 변수의 값은 실행 시에 결정되므로 컴파일러는 이 값의 범위를 확인할 수 없기 때문이다.



배열의 길이의 최대값은 int타입의 최대값, 약 20억이다.

```java
arr.length;  // 배열의 길이, 상수이다.
```

### 길이가 0인 배열

java에서는 길이가 0인 배열도 지원한다. 따라서 다른 언어와 달리 배열이 비어있는 경우를 따로 예외처리를 하지 않고 사용할 수 있어서 좀 더 간편하다.

ex) 입력값이 없는 경우 : 배열의 기본값은 null이라 배열을 생성하지 않는다면 다른 부분에서 예외가 날 수 있는데 이때 크기가 0인 배열을 생성해서 사용하면 따로 예외처리를 해주지 않아도 된



배열은 한번 선언되고 나면 길이를 변경할 수 없다. 배열의 길이를 변경하기 위해서는 더 큰 길이의 배열을 새로 생성하고 기존 배열의 값을 새로운 배열에 복사해야 한다.

for문으로 직접 구현할 수도 있지만 Sytem 클래스의 `arraycopy()`를 사용해서 더 빠르게 간편하게 배열을 복사할 수 있다.

```java
System.arraycopy(원본, 원본 시작인덱스, 목적지, 목적지 시작인덱스, 복사할 문자열의 길이);
```

`Arrays.toString(배열이름)` 메서드를 사용해 배열의 모든 요소를 일정한 형식의 문자열로 출력할 수 있다.

배열을 그대로 출력하면 `타입@주소` 형식으로 출력된다. 예외적으로 char 배열은 print, println 로 출력하면 각 요소가 구분자 없이 그대로 출력된다.

### 가변 배열

java에서는 2차원 이상의 배열을 `배열의 배열` 형태로 저장하기 때문에 다음과 같이 배열을 구성하는 것이 가능하다.

```java
int[][] arr = new int[3][];arr[0] = new int[5];arr[1] = new int[3];arr[2] = new int[4];
```

연습문제 - BOJ 14912 숫자 빈도수

연습문제 - BOJ 5691 Mean Median Problem

### 문자열

```java
String s1 = new String("abc");
String s2 = "abc";  // 객체 중 String만 new를 사용하지 않고 간단하게 객체생성 가능
String s3 = "Abc";

System.out.println(s1 == s2);  // false. 객체 자체를 비교.
System.out.println(s1.equals(s2));  // true. 문자열의 내용을 비교.
System.out.println(s1.equalsIgnoreCase(s2));  // 대소문자 구별없이 비교.
```

String 클래스는 char배열에 기능(메서드)를 추가한 것.

이때 char배열과 달리 String객체는 읽을 수만 있고 내용을 변경할 수는 없다는 점에 주의.

#### String 클래스 주요 메서드

* `char charAt(int index)`

  C++과는 달리 괄호연산자를 기본적으로 지원하지 않는다.

* `int length()`

* `String substring(int fromt, int to)`

* `boolean equals(Object obj)`

* `boolean equalsIgnoreCase(Object obj)`

* `char[] toCharArray()`

## 객체지향언어

### 객체지향이론

```기본개념
<기본개념>
실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다.
```

과학실험 등 모의실험을 위해 가상세계를 컴퓨터에 구현하기 위한 노력으로 탄생하였다.

실제 사물의 속성과 기능을 분석한 다음, 데이터(변수)와 함수로 정의해서 가상세계를 구현하고 모의 실험을 하는데 사용되었다.

이후 1960s 객체지향이론을 프로그래밍언어에 적용한 `시뮬라`가 처음 등장했다. 하지만 그 당시 에는 `FORTRAN` 등 절차적 언어들이 주로 사용되었다.

시간이 지나면서 프로그램의 규모가 커지고 사용자들의 요구가 빠르게 변화해가면서 절차적언어의 한계를 느끼고 객체지향언어의 입지가 점차 커지다가 `java`의 등장 이후 널리 사용되게 되었다.

### 객체지향언어

```
기존의 언어에 몇 가지 규칙들을 추가해 코드 간에 관계를 형성해
보다 유기적으로 프로그램을 구성하는 것이 가능해진 언어
```

#### 재사용성, 유지보수, 중복된 코드 제거

프로그램의 개발과 유지보수에 드는 시간과 비용을 획기적으로 개선하였다.

* **클래스** - 객체를 정의해 놓은 것. 객체를 만들때 사용.

  `인스턴스화(instantiate)`

  > 클래스로부터 객체를 만드는 과정

  `인스턴스(instance)`

  >  클래스로부터 만들어진 객체. 어떤 클래스로부터 만들어진 것인지를 강조.
  >
  > ```
  > String num = new String("java");
  > ```
  >
  > num은 객체다. / num은 String 클래스의 인스터스이다.
  >
  > 이때 num 자체는 객체가 아니고 객체를 참조하는 변수이다. new 연산자를 통해 객체가 생성되고 해당 객체의 주소를 참조형 변수를 통해 가리키는 것이다.

* **객체** - 실제로 존재하는 것.

  * 유형의 객체
  * 무형의 객체 - 개념, 논리 같은 것들도 객체로 간주된다.

  속성, 기능을 갖는다. 객체지향언어에서는 **멤버변수**, **메서드**라고 불린다.

  > 객체는 참조변수를 통해서만 다룰 수 있다.
  >
  > 이때 객체와 참조변수의 타입이 일치해야한다.


연습문제 - BOJ 4673 Self Numbers

 배열 생성은 [], 객체 생성은 ()

```java
String[] arr = new String[2];
arr[0] = new String("first");
arr[1] = "second";  // String 클래스는 유일하게 객체를 생성할때 new 생략 가능.
```

### 변수

* 멤버변수

  클래스 내부에서 선언된다

  * **인스턴스 변수**

    인스턴스가 생성될 때 생성.

  * **클래스변수**

    해당 클래스의 모든 인스턴스가 공유하는 변수. 인스턴스가 없어도 사용할 수 있다.

    `클래스이름.클래스변수` (인스턴스 변수처럼 참조형 변수를 통해서도 사용할 수 있다)

    static을 자료형 앞에 붙여서 사용. 앞에 `public`을 붙이면 `전역변수`의 성격을 갖는다.

    클래스가 메모리에 올라갈 때 생성. (참조변수의 선언이나 객체의 생성과 같이 클래스의 정보가 필요할 때 클래스는 메모리에 로딩된다.)

* **지역변수**

  메서드 내에 선언된 변수. 메서드가 실행될 때 생성.

```java
class EX {
	int a;  // 지역변수 - 인스턴스변수
    static int b;  // 지역변수 - 클래스변수
    void method() {
		int c;  // 지역변수
    }
}
```

### 메서드

내부적인 동작 과정을 몰라도 입출력만 알고있다면 사용할 수 있기 때문에 `블랙박스`라고도 한다.

대표적인 장점 3가지

1. 높은 재사용성
2. 중복된 코드 제거 -> 유지 보수 굿
3. 프로그램의 구조화 -> 유지 보수 굿

선언부와 구현부

인자와 매개변수

#### static 메서드

객체를 생성하지 않고 메서드를 호출하기 위해선 메서드 앞에 `static`을 붙여야 한다.

같은 클래스 내의 메서드끼리는 참조변수를 사용하지 않고도 서로 호출할 수 있다.

하지만 static메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수 없다.

#### 매개변수의 유효성 검사

부적절한 값이 매개변수로 전달되는 경우 매개변수의 값을 보정하거나, 메서드를 종료하는 등 예외 처리를 해주어야 한다.

#### 참조형 매개변수

c나 c++과 달리 참조형변수나 포인터변수가 따로 존재하지 않는다.

따라서 예를 들어 int형 참조형 매개변수를 사용하고 싶다면 길이가 1인 int형 배열을 사용한다.

그리고 구조체나 클래스도 항상 주소값으로 전달된다. (C나 C++에서는 포인터를 사용하지 않는다면 값이 복사되서 들어간다.) 

### JVM의 메모리 구조

1. **메서드 영역 (method area)**

   클래스에 대한 정보(클래스 데이터), 클래스 변수가 저장되는 곳

2. **힙 (heap)**

   인스턴스 변수들이 생성되는 공간

3. **호출스택(call stack / execution stack)**

   메서드의 작업에 필요한 메모리 공간.

   메서드의 지역변수, 연산의 중간결과 등을 저장하는데 사용된다.

   메서드가 작업을 마치면 할당되었던 메모리 공간은 반환되어 비워진다.

   ````
   나중에 호출된 메서드를 먼저 처리하기 때문에 스택을 사용하게 된다.
   ````

   `StackOverflowError`가 나오는 부분.

   ex) 함수를 너무 많이 호출했을때, 재귀함수가 무한루프에 빠졌을때 등

