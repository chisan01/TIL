[BOJ 1181 단어 정렬](https://www.acmicpc.net/problem/1181)

> bubble_sort로 구현시 시간초과  
> merge_sort 복습

[BOJ 15353 큰 수 A+B(2)](https://www.acmicpc.net/problem/15353)
> 전에 이 문제를 푸느라 애먹었던 기억이 나서 다시 한번 풀어봤다.   
> 성공. 종만북에서 한번 풀어봐서 그런가 그래도 수월하게 풀었다.

### 브루트 포스 알고리즘 (종만북 - 무식하게 풀기)

모든 경우의 수를 탐색하는 알고리즘.     
대표적으로 순차 탐색, 깊이우선탐색(DFS), 너비우선탐색(BFS)을 사용한다.

문제 해결 방법
1. 주어진 문제를 선형 구조로 구조화한다.
2. 구조화된 문제공간을 적절한 방법으로 해를 구성할 때까지 탐색한다.
3. 구성된 해를 정리한다.

[BOJ 1436 영화감독 숌](https://www.acmicpc.net/problem/1436)     

브루트포스가 새로운 알고리즘인줄 알았는데 이미 종만북에서 봤었던 "무식하게 풀기"랑 이름만 다르고 내용은 같아서 그렇게 한번 풀어봤는데 아...? 그냥 무식하게 666부터 해당 숫자가 10000개가 나올때까지 for문 돌려서 배열에 저장해서 하니깐 성공했다.     
뭔가 좀 허무하긴 하지만 성공. solved.ac class 2++도 완료했다.    

[BOJ 9935 EXSPLOZIJA](https://www.acmicpc.net/problem/9935)     

작년에 시도해봤다가 못 풀었던 문제.      

메모리 초과. 입력되는 string의 길이도 긴데 재귀함수로 구현하면서 너무 많은 string을 사용해서 그런것같다.     
-> 검사 방식을 바꾸고 매개변수도 참조형으로 바꾸니깐 50%에서 메모리초과.      
-> 배열을 새로 만드는대신 erase 내장 함수 활용. 57%에서 시간초과.     
-> find랑 erase로 코드를 엄청 짧게 짤수있지만 2%에서 시간초과.        
-> stack을 활용해서 한번에 처리할 수 있지 않을까. 폭발물인지 검사하다가 끊겼는데 폭발물의 첫글자인경우는 이어서 셀 수 있다.     
-> Segfault. 폭발물이 중간에 끊겼을때 check를 0으로 초기화하지 않으면서 이상한 곳을 참조하면 오류가 났다.    
-> 시간초과. 아무래도 erase를 수행하면서 시간이 많이 걸리는것같다. erase대신 문자열을 deque에 저장해버리자.     
-> 성공. 36ms.    

[BOJ 9659 돌 게임 5](https://www.acmicpc.net/problem/9659)    

성공. 0ms. 규칙만 찾아낸다면 정말 쉬운 문제.    

[BOJ 1927 최소 힙](https://www.acmicpc.net/problem/1927)    

성공. priority_queue를 사용하면 쉽게 풀 수 있긴하다 (16ms)    

자료구조 복습겸 직접 heap을 구현.     

런타임에러(segfault).      

성공. 배열을 동적할당해서 썼다가 100000 크기 배열을 썼더니 성공했다.

### heap

    heap property(heap-order)를 만족하는 complete binary tree.
    
    heap property(heap-order)    
    : parent 노드가 child node보다 무조건 작다.



### Codefoces Round #739 (Div. 3)

[D, Make a Power of Two](https://codeforces.com/contest/1560/problem/D)

2의 제곱들과 앞자리수부터 비교

> ex) 1052
>
> 1024중에서 102까지 겹친다.
>
> 4-3+(4-3) = 2
>
> ex) 888
>
> 8중에서 모든 자리가 겹친다.3-1 = 2

384와 같은 경우 3자리 숫자지만 5자리 숫자인 16384에서 최소값 2를 갖는다.

> -> 1자리 숫자인 4나 8에서도 최소값 2를 갖는다.
>
> n자리 숫자인 경우 n자리 2의 제곱수 까지만 확인해보면 될것같다.
>
> -> 6인 경우 1자리 숫자지만 2자리 숫자인 64가 최소값 1을 갖는다.

그래서 자리수 상관없이 모두 돌려봤는데 test case 4에서 오답이 나온다.

해설지를 참고해서 풀었다.

최악의 경우 맨 끝자리에 1을 붙이고 나머지 자릿수를 다 삭제하면 2의 제곱이므로 n자리수의 경우 결과값은 최대 n+1이다. 따라서 n자리수의 경우 2n자리수까지만 고려해주면 된다.

2제곱 배열을 10^18까지 저장하도록 변경했더니 맞았다.

bruteforce 알고리즘. 언뜻보면 n이 최대 10^9라 시간복잡도가 커보이지만 문자열로 저장해서 각 자리수만 검사하기 때문에 시간복잡도가 크지 않다.

거의 다 맞은거였는데 조금 아쉽다.



[BOJ 2206 벽 부수고 이동하기](https://www.acmicpc.net/problem/2206)

최근에 풀어봤던 icpc 2020 온라인 예선에 나왔던 문제 중 다익스트라 알고리즘을 사용하는 문제랑 되게 비슷하다.

되게 비슷해서 이것도 다익스트라 알고리즘으로 풀어야 되나 싶었지만 약간 달랐다.

> 1. 벽 안 부수고 갈 수 있는 최단경로
> 2. 벽 하나마다 부수고 벽을 포함하는 최단경로

여러가지 경우를 생각해봤는데 다 시간복잡도가 높아서 시간초과가 난다.

결국 생각이 안나서 알고리즘 분류를 봤는데 BFS였다.

하지만 BFS인걸 알아도 어떻게 풀어야 할지 감이 잘 안와서 결국 인터넷에서 풀이를 참고했다.

[참고1](https://jaimemin.tistory.com/650) [참고2](https://herong.tistory.com/m/entry/BOJ-2206-%EB%B2%BD-%EB%B6%80%EC%88%98%EA%B3%A0-%EC%9D%B4%EB%8F%99%ED%95%98%EA%B8%B0-Java#:~:text=%EC%8B%9C%EA%B0%84%20%EB%B3%B5%EC%9E%A1%EB%8F%84%20%EA%B3%84%EC%82%B0%2C%20%EC%A0%84%ED%98%80%20%EC%96%B4%EB%A0%B5%EC%A7%80,%EB%9B%B0%EC%96%B4%EB%84%98%EB%8A%94%201%EC%A1%B0%EC%9E%85%EB%8B%88%EB%8B%A4.)

```
0 1 0 0 1 0
0 1 0 1 1 0
0 1 0 1 1 0
0 0 0 1 1 0
```

이런 경우에 유일한 경로를 앞에서 다른 벽을 뚫고 방문해버려서 최단경로가 존재하지만 없는걸로 나올줄 알았는데 벽을 뚫고 방문하는 경우와 벽을 뚫지 않고 방문하는 경우 2가지로 나눠서 체크하면 된다.

BFS가 어떤 알고리즘인지는 알고, 구현도 할 수 있지만 아직 응용이 잘 안된다. 관련 문제들을 아직 많이 풀어봐야 할 것 같다.

> 블로그를 보니깐 가중치가 없는 최단경로는 무조건 BFS라고 한다.

조금 애먹긴 했지만 소스코드는 보지 않고 구현 성공.



## solved.ac

### CLASS 2+

[BOJ 2751 수 정렬하기 2](https://www.acmicpc.net/problem/2751) - 해결(merge sort)

[BOJ 11866 요세푸스 문제 0](https://www.acmicpc.net/problem/11866) - 성공

[BOJ 9012 Parenthesis](https://www.acmicpc.net/problem/9012) - 성공

[BOJ 11650 좌표 정렬하기](https://www.acmicpc.net/problem/11650) - 성공

[BOJ 1181 단어 정렬](https://www.acmicpc.net/problem/1181) - 성공   

>직접 merge sort로 구현하려고 하니깐 머리도 아프고 오류도 계속 났는데 map을 이용하니깐 엄청 간단하게 구현할 수 있었다.

[BOJ 10814 나이순 정렬](https://www.acmicpc.net/problem/10814) - 성공

[BOJ 10866 덱](https://www.acmicpc.net/problem/10866) - 성공

[BOJ 1018 체스판 다시 칠하기](https://www.acmicpc.net/problem/1018) - 성공   

>https://www.acmicpc.net/submit/1018/32219355 성공한 코드들이랑 다를게 없는 거 같은데 채점해보면 틀렸다고 나온다.

[BOJ 15829 Hashing](https://www.acmicpc.net/problem/15829)   

> 성공 - modular 연산만 잘 알고 있다면 쉽게 풀수있는 것 같다.   

[BOJ 1436 영화감독 숌](https://www.acmicpc.net/problem/1436)

> 보류 - 몇번째 숫자를 어떻게 구해야할지 생각하기가 좀 어렵다.   
> 규칙을 어느정도 찾아서 구현하고 있는데 어우 어렵다..   
> 실패 - 실수로 7번째에 6660이 아니라 6000을 출력했다.   
> 실패 - 어디서 실패한건지 모르겠다. 오버플로우가 나서 그런가 해서 long long으로 바꿨는데 여전히 오답으로 나온다. 어디서 중복이 나는 경우를 고려하지 못한거같다.   

> https://st-lab.tistory.com/103    
> 찾아보니 브루트포스 알고리즘을 이용해서 문자열로 풀면 쉽게 풀 수 있는 문제인것 같다. 그리고 나처럼 int로 구간을 나눠서 푼 사람도 있어서 참고하려고 했는데 방식이 조금 달라서 내 방법으로 다시 첨부터 차근차근 해봤다.    

> 10000을 입력했을때 266799가 나와야하는데 2662666이 나오는걸보면 아무래도 중복해서 센 부분이 있는 것 같다.    
> 손으로 직접 써가면서 풀어봤는데 2860에서 원래 699666이 나와야되는데 이상한 값이 나오는것을 발견했다.    
> 계속 하면 할수록 예외 처리 해야되는게 새로 나와서 끝이 없다... 이문제에만 몇시간을 쓴건지 모르겠다.   

> 더 이상하는건 미련인 것 같아서 다른 사람의 코드를 참고해서 해결하기로 결정했다.   
> 그리고 앞으로도 문제를 해결할때는 한시간안에 못풀면 다른 사람의 코드를 참고하기로 결정했다.   


#### 오늘의 교훈

> 알고리즘 문제를 풀때 어느정도 시간을 정해두고 정 안풀리면 다른 사람들 코드를 참고해서 공부하자.    
> 아직 모르는 알고리즘 개념도 많고 경험도 적어서 오래 고민하더라도 풀리지 않을 가능성이 높다. 그리고 그 시간에 다양한 문제를 풀어보는게 오히려 더 도움이 될 것 같다.   

> 어떤 블로그에서 알고리즘 문제 풀때 한문제를 너무 오래 붙잡고 있는것은 오히려 독이 된다고 시간을 정해두고 푸는 것이 좋다고 했는데 오늘 정말 뼈저리게 느낀다..    


[BOJ 2805 EXO](https://www.acmicpc.net/problem/2805)

> 성공. 중간에 자료형을 잘못써서 한번 틀리긴 했지만 그래도 최근에 분할 정복 문제를 많이 풀어봐서 그런가 수월하게 풀었다.

[BOJ 10989 수 정렬하기 3](https://www.acmicpc.net/problem/10989)

> 성공. 처음에 vector로 풀었다가 메모리 초과가 나서 map으로 다시 풀었다.

[BOJ 11651 좌표 정렬하기 2](https://www.acmicpc.net/problem/11651)

> 성공. 뭔가 꼼수인거 같기도 하지만 x랑 y 위치만 바꿔서 map이랑 pair 이용해서 풀었다.

[BOJ 1966 Printer Queue](https://www.acmicpc.net/problem/1966)

> 보류 - 조금 생각이 필요할 것 같다. 앞에 있는 우선순위가 낮은 수들을 뒤로 옮기는 과정에서 변동이 생겨서 단순히 우선순위큐를 써서 풀 수는 없는 것 같다.   
> 성공 - 큐에 우선순위와 인덱스를 저장해서 사용하고, 우선순위를 체크하기 위해서 크기 10짜리 벡터를 하나 만들어서 관리하는 방식으로 구현했다. 꽤 까다로웠다.

[BOJ 10773 Zero That Out](https://www.acmicpc.net/problem/10773)

> 성공. stack만 안다면 쉽게 풀 수 있는 문제인것 같다.

[BOJ 2108 통계학](https://www.acmicpc.net/problem/2108)

> 성공. 엄청 간단할 줄 알았는데 최빈값을 어떻게 구할지 생각이 잘 안나서 좀 힘들었다.

[BOJ 4949 The Balance of the World](https://www.acmicpc.net/problem/4949)

> 성공. 괄호 종류만 2개로 늘어나고 전에 풀어봤던 문제랑 비슷해서 수월하게 풀 수 있었다.

[BOJ 18111 마인크래프트](https://www.acmicpc.net/problem/18111)

> 성공. 28ms. map을 이용해서 풀었다.   
> 지금은 실버 정도 난이도가 나한테 잘 맞는 것 같다. 적당히 어려워서 고민을 좀 해야 풀리다보니 성취감도 느껴지고 좋다.

[BOJ 1874 스택 수열](https://www.acmicpc.net/problem/1874)

> 성공. 20ms. stack을 이용해서 직접 돌려보는 식으로 구현했다.

[BOJ 7568 덩치](https://www.acmicpc.net/problem/7568)

> 성공. 입력의 크기가 작은걸 보고 O(n^2)으로 그냥 무식하게 풀어버려도 될 것 같아서 수월하게 풀었다.

### CLASS 3

[BOJ 11723 집합](https://www.acmicpc.net/problem/11723)

성공. 724ms. map을 이용해서 풀었다.

[BOJ 1003 피보나치 함수](https://www.acmicpc.net/problem/1003)

성공. n의 범위를 n<40으로 처음에 잘못 설정해서 틀렸다.

문제 자체는 일반적인 피보나치랑 크게 다르지 않아서 dp를 이용해서 쉽게 구현했다.

[BOJ 9095 Adding 1s, 2s, and 3s](https://www.acmicpc.net/problem/9095)

1,2,3만 사용하고 순서도 고려해야 되서 생각보다 까다롭다.

성공. nCr을 이용해서 풀었다.

```
3이 x개, 2가 y개, 1이 z개
배열하는 방법: (x+y+z)!/(x!y!z!)
```

[BOJ 11399 ATM](https://www.acmicpc.net/problem/11399)

성공. 굉장히 수월하게 풀었다. 먼저 돈을 뽑을수록 전체 소요시간에 영향을 많이 미치기 때문에 오름차순으로 정렬해서 풀면 된다.

[BOJ 1620 나는야 포켓몬 마스터 이다솜](https://www.acmicpc.net/problem/1620)

시간초과. O(n^2) 알고리즘을 사용하면 최대 10억이라 시간초과가 난다.

성공. vector랑 map을 사용해서 풀었다.

요새 골드를 주로 풀어서 그런가 실버 4,5 정도 문제는 큰 어려움이 없이 수월하게 풀린다.

[BOJ 1764 듣보잡](https://www.acmicpc.net/problem/1764)

map을 이용하면 쉽게 풀 수 있을 것 같다.

성공. 처음에 사전 순이라는 조건을 못보고 풀어서 틀렸다.

[BOJ 11726 2xn 타일링](https://www.acmicpc.net/problem/11726)

처음에는 2x1 타일 2개를 어디에 몇개나 배치할지 조합으로 풀려고 했는데 묶음끼리 한칸씩 떨어진 경우를 고려하지 못했다.

좀 더 고민을 해보니 피보나치랑 똑같은 문제라는걸 알게되었다.

앞에 1x2 타일이 오거나 2x1 타일 2개가 올 수 있는데 각각의 경우는 n-1, n-2만큼씩 있다.

성공.

[BOJ 11444 피보나치 수 6](https://www.acmicpc.net/problem/11444)

어렵군..

[BOJ 2630 색종이 만들기](https://www.acmicpc.net/problem/2630)

쪼개서 풀면 될거같다. 예를 들어 4칸 짜리 사각형은 1칸짜리 사각형으로 이루어져있다.

따라서 해당사각형을 이루고 있는 사각형이 모두 같은 색깔이면 1개. 그게 아니라면 해당 사각형을 이루고 있는 사각형들을 이루고 있는 사각형들의 개수의 합.

하지만 구현하는게 쉽지않다. 정리해서 써보고 코딩으로 구현하자.

1. 이미 다른 색으로 구성된 경우

   -> 고려 x

2. 같은 색으로 구성되어있지만 다른 사각형과 색이 같지 않은 경우

   -> 흰/파 개수 정산, 결과값에 반영 -> 1번 경우라는 것을 나타내기 위해 -1반환

3. 4개다 색이 동일한 경우

   -> 다음단계로 패스(사각형 한개로 취급). 0또는 1반환.

성공.

[BOJ 1012 유기농 배추](https://www.acmicpc.net/problem/1012)

왼쪽위에서 오른쪽 아래로 진행. 배추의 왼쪽이나 위에 배추가 없다면 새로운 집합으로 간주.

실패.

```
11
01
11
```

예제는 다 통과했지만 이런 예외 상황을 고려하지 못했다.

재귀함수처럼 구현하는 게 좋을것같다.

한 배추를 정해서 상하좌우를 탐색해서 방문하지 않은 배추 방문.

실패. 배열들의 값을 초기화해주지 않고 사용해서 오답이 나온것같다.

그리고 저번에도 이런 적이 있는데 범위를 잘못 지정해서 OutOfBounds 런타임 에러가 나왔다.

(n, m의 범위가 0부터 50까지인데 크기가 50*50인 배열을 사용했다.)

성공.

[BOJ 1931 회의실 배정](https://www.acmicpc.net/problem/1931)

LIS 문제랑 비슷한 거 같다.

O(n^2) 알고리즘을 사용했는데 입력의 크기가 10만이라 역시나 시간초과가 나온다.

일반적인 LIS와 달리 시작시간과 끝시간이 있어서 고려해야 하는 케이스가 좀 더 많아서 구현하기 까다로운 것 같다.

어떻게 최적화를 해야할까..

1. 오름차순으로 정렬(시작, 종료 시간 기준)
2. 회의 벡터에 저장
3. 벡터에 저장된 마지막 회의를 기준으로
   1. 종료시간이 더 작은 경우 -> 교체
   2. 시작시간이 종료시간보다 늦는 경우 -> 추가

성공.

[BOJ 11724 연결 요소의 개수](https://www.acmicpc.net/problem/11724)

BFS로 간단하게 풀 수 있을 것 같다. 성공.

[BOJ 18870 좌표 압축](https://www.acmicpc.net/problem/18870)

입력의 크기가 백만이라 O(n^2)으로 구현하면 시간초과가 나올 것 같은데 O(n^2)인 아닌 방법으로 어떻게 구해야할지 잘 모르겠다. 한번 제출해봤는데 역시나 시간초과.

입력받으면서 몇번째 숫자인지 업데이트 해나가는 방식은 O(n^2)이 아닌 방법으로 구현할 수 없는 것 같다.

정렬한 배열을 따로 저장해서 이진 탐색으로 몇번째 숫자인지 출력하면 O(nlogn)으로 구현할 수 있지 않을까

map을 이용해서 풀었다. 성공.

다른 사람의 풀이를 봤는데 어렴풋이 생각했던 방법이지만 구현하지 못했던 방법이었다.

(벡터에 좌표랑 인덱스를 같이 저장해서 정렬을 하고 맨 앞부터 차례대로 검사해서 숫자가 같으면 같은 순위를 사용하고 이외에는 순위를 점차 증겨시켜나가면서 크기가 n인 결과값을 저장할 배열의 해당 인덱스에 순위를 저장시킨뒤 출력.)

[BOJ 1074 Z](https://www.acmicpc.net/problem/1074)

while(n--)

0 + 2^(2\*n)\*(r/(2^n)\*2 + c/(2^n)) + ...

r%=(2^n)	c%=(2^n)

성공.

[BOJ 7576 토마토](https://www.acmicpc.net/problem/7576)

상자 최대 크기 1000,000

O(n^2) 알고리즘으로 구현하면 시간초과가 나올 것이다.

bfs로 풀면 될 것 같다. 입력받으면서 익은 토마토들 위치를 queue에 넣고 인접한 안 익은 토마토들 익은 토마토로 바꾸고 queue에 넣기.

성공.

### CLASS 4

[BOJ 15650 N과 M(2)](https://www.acmicpc.net/problem/15650)

성공. 재귀함수로 쉽게 풀었다.

[BOJ 15652 N과 M (4)](https://www.acmicpc.net/problem/15652)

성공. BOJ 15650이랑 거의 똑같은 문제. 요즘 java를 공부중이라 연습삼아 java로 풀었다.

[BOJ 15654 N과 M (5)](https://www.acmicpc.net/problem/15654)

성공.

[BOJ 15657 N과 M(8)](https://www.acmicpc.net/problem/15657)

성공.

미해결 - [BOJ 2407 조합](https://www.acmicpc.net/problem/2407)

일반적인 방법으로 구현하면 8byte 자료형을 쓰더라도 overflow가 생긴다.

최대값인 100C50의 경우 결과값도 8byte를 넘어가버린다.

문자열을 이용해서 계산해야 할 것 같은데 나눗셈은 어떻게 계산해야할지 감이 잘 안잡힌다.

[BOJ 9465 Stickers](https://www.acmicpc.net/problem/9465)

DP로 풀면 되겠다 싶었는데 10만*10만 짜리 배열을 사용해야 되서 컴파일에러가 날 것 같다.

```
int dp[1번째 줄 index][2번째 줄 index] = 스티커의 최대값
```

같은 열에는 한가지 스티커만 존재할 수 있으므로 2*10만 크기의 배열을 사용해서 dp로 풀면 될 것 같다.

```
int dp[row][col] = 스티커의 최대값
```

뭔가 구현이 잘 안돼서 좀 더 생각을 해봤다.

```
int dp[col][그 전 col에서 어느 스티커를 사용했는지][sum]
```

성공. 316ms

```
int dp[col][그 전 col에서 어느 스티커를 사용했는지] = 최대값
```

최대값이 몇 번째 col인지, 그 전 col에서 어느 스티커를 사용했는지에만 영향을 받으므로 이렇게 dp를 사용할 수 있다.

> 역시 아직 DP에 익숙해지지 않은 것 같다.

DP를 사용할 때 결과값이 결정되는 조건을 잘 파악하는 것이 중요한 것 같다.

> DP의 특성 - 최적 부분 구조



## 단계별로 풀어보기

### DFS와 BFS

[BOJ 2667 단지번호붙이기](https://www.acmicpc.net/problem/2667)

성공. DFS 재귀함수로 구현.

성공. DFS 반복문으로 구현.

[BOJ 7568 토마토](https://www.acmicpc.net/problem/7569)

처음에 어떻게 풀어야할지 감이 잘 안왔는데 BFS를 조금 응용해서 풀면 된다.

익은 토마토 위치를 다 queue에 넣어놓고 시작하면 된다.

성공.

[BOJ 7562 Knight Moves](https://www.acmicpc.net/problem/7562)

성공. 전형적인 BFS 문제

[BOj 1707 이분 그래프](https://www.acmicpc.net/problem/1707)

BFS나 DFS를 하면서 adj list를 검색하면서 아직 방문하지 않은 경우 !visit[cur]으로 설정. 방문한 경우 visit 값이 visit[cur]와 같으면 NO

오답. connected graph만 고려해서 그런 것 같다.

성공.

### 최단경로

[BOJ 1753 최단경로](https://www.acmicpc.net/problem/1753)

다익스트라 구현 문제.

[BOJ 1504 특정한 최단 경로](https://www.acmicpc.net/problem/1504)

1에서 v1까지의 거리, 1에서 v2까지의 거리

끝에서 v1까지의 거리, 끝에서 v2까지의 거리

> v1, v2까지의 경로가 모두 존재하는 경우,
>
> 1. v1을 거쳐 v2로 가는 경우
> 2. v2를 거쳐 v1로 가는 경우
>
> 비교해서 결과값 출력

 v1에서 v2까지의 거리

다익스트라 알고리즘을 총 3번 수행해야 한다. 다익스트라 알고리즘의 시간복잡도는 O(n+mlogn)으로 시간초과없이 가능할 것 같다.

런타임에러(OutOfBounds), 런타임에러(WithoutReturning)

> 구현하면서 조금 실수가 있었다.

84%에서 오답. 출발점이 v1이고, 도착점이 v2인 경우 고려 x.

```
2 1
1 2 4
1 2 
- 1
```

성공.

[BOJ 9370 Destination Unknown](https://www.acmicpc.net/problem/9370)



[BOJ 11657 타임머신](https://www.acmicpc.net/problem/11657)

벨만 포드 알고리즘. [참고](https://ratsgo.github.io/data%20structure&algorithm/2017/11/27/bellmanford/)

> 모든 edge를 방문하면서 최단경로를 업데이트하는 과정을 정점개수-1만큼 반복한다.
>
> 따라서 시간복잡도는 O(nm) = O(v^3)
>
> 음수 사이클이 존재하면 사이클을 돌면 돌수록 값이 작아져서 최단 경로를 구할 수 없다.

음수 사이클 존재여부를 어떻게 체크할 수 있을까

1번 도시까지의 최단경로가 음수값이 되면 사이클이 존재한다고 간주하려고 했지만 이 방법으로는 1번도시가 음수 사이클에 포함되지 않는 경우는 고려할 수 없다.

모든 edge를 반복하는 과정 도중에 이미 반복한 정점까지의 최단 경로가 다시 업데이트 되는 경우 음수 사이클이 존재한다.

1%에서 오답.

> 모든 edge를 반복하는 과정을 정점 수 만큼 반복한뒤 모든 edge를 다시 방문했을때 값이 업데이트되면 음수사이클이 있다는 것이다.

출력초과. 음수사이클 체크가 제대로 되지 않는 경우가 있는 것 같다.

> 질문검색 게시판에서 찾았는데 최소 거리를 int형 변수에 저장해서 오버플로우가 발생되서 그런거였다.
>
> 버스 노선이 최대 6000개에 각각 최대 10,000시간이라 최대 60,000,000이라 오버플로우가 발생하지 않을줄 알았는데 오버플로우가 발생하나보다.
>
> [참고](https://steady-coding.tistory.com/92) 
>
> 좀 더 생각을 해보니 음수 싸이클이 존재하는 경우 계속 반복하면서 값이 누적되면 최소값이 -10000 x 6000 x 500 = 약 -30억이라 오버플로우가 생긴다.

성공.

알고리즘 과제 하는겸 다시 구현해 봤다. 이번에도 오버플로우를 발견하지 못하긴 했지만 알고리즘 자체는 참고 자료 없이 구현 성공.

[BOJ 11404 플로이드](https://www.acmicpc.net/problem/11404)

몇몇 값이 최소 비용으로 나오지 않는데 이유를 잘 모르겠어서 그전 풀이를 참고했다. -> 저번처럼 시작도시와 도착도시가 같은 버스가 여러 개 존재할 수 있다는 걸 놓쳤다.

성공.

[BOJ 10217 KCM Travel](https://www.acmicpc.net/problem/10217)



[BOJ 1956 운동](https://www.acmicpc.net/problem/1956)



### Stack

[BOJ 10828 스택](https://www.acmicpc.net/problem/10828)

오랜만에 감도 다시 잡을겸 linked_list로 스택 구현.

전에 풀었을때는 배열을 동적할당해서 4ms가 나왔고 이번에 0ms가 나왔다.



## [plzrun's algorithm](https://plzrun.tistory.com/entry/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4PS-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0)

### DP

[BOJ 2xn 타일링 2](https://www.acmicpc.net/problem/11727)

성공. 반복문이랑 재귀함수 2가지 방법으로 구현해봤다.

[BOJ 쉬운 계단 수](https://www.acmicpc.net/problem/10844)

길이가 N인 계단 수 = 길이가 N-1인 계단 수*2 - 길이가 N-1이고 0이나 9로 끝나는 계단 수

> 0이나 9는 1 차이나는 수가 1, 8로 하나씩밖에 없다.

0이나 9를 제외한 숫자는 길이가 1씩 증가할때마다 2배씩 증가할 줄 알았는데 1을 예시로 들어서 생각해보니 1은 0, 2로 끝나는 계단 수만큼 증가하기 때문에 2배보다 적게 증가한다.

마지막에 계단 수를 더할때 나머지 연산을 깜빡해서 틀렸다. 성공.

[BOJ 오르막 수](https://www.acmicpc.net/problem/11057)

간단한 구현 문제. 성공.

[BOJ 이친수](https://www.acmicpc.net/problem/2193)

값이 커질 것을 고려하지못하고 int형으로 풀었다가 틀렸다. 성공.

[BOJ 포도주 시식](https://www.acmicpc.net/problem/2156)

구현이 생각보다 까다로웠지만 그림을 그려보니깐 수월하게 풀 수 있었다.

https://www.acmicpc.net/problem/11055

https://www.acmicpc.net/problem/11722

https://www.acmicpc.net/problem/11054

https://www.acmicpc.net/problem/2579

https://www.acmicpc.net/problem/1699

https://www.acmicpc.net/problem/2133

https://www.acmicpc.net/problem/9461

https://www.acmicpc.net/problem/2225

https://www.acmicpc.net/problem/2011

https://www.acmicpc.net/problem/11052

