[BOJ 1181 단어 정렬](https://www.acmicpc.net/problem/1181)

> bubble_sort로 구현시 시간초과  
> merge_sort 복습

### solved.ac CLASS 2+

[BOJ 2751 수 정렬하기 2](https://www.acmicpc.net/problem/2751) - 해결(merge sort)

[BOJ 11866 요세푸스 문제 0](https://www.acmicpc.net/problem/11866) - 성공

[BOJ 9012 Parenthesis](https://www.acmicpc.net/problem/9012) - 성공

[BOJ 11650 좌표 정렬하기](https://www.acmicpc.net/problem/11650) - 성공

[BOJ 1181 단어 정렬](https://www.acmicpc.net/problem/1181) - 성공   
>직접 merge sort로 구현하려고 하니깐 머리도 아프고 오류도 계속 났는데 map을 이용하니깐 엄청 간단하게 구현할 수 있었다.

[BOJ 10814 나이순 정렬](https://www.acmicpc.net/problem/10814) - 성공

[BOJ 10866 덱](https://www.acmicpc.net/problem/10866) - 성공

[BOJ 1018 체스판 다시 칠하기](https://www.acmicpc.net/problem/1018) - 성공   
>https://www.acmicpc.net/submit/1018/32219355 성공한 코드들이랑 다를게 없는 거 같은데 채점해보면 틀렸다고 나온다.

[BOJ 15829 Hashing](https://www.acmicpc.net/problem/15829)   
> 성공 - modular 연산만 잘 알고 있다면 쉽게 풀수있는 것 같다.   

[BOJ 1436 영화감독 숌](https://www.acmicpc.net/problem/1436)
> 보류 - 몇번째 숫자를 어떻게 구해야할지 생각하기가 좀 어렵다.   
> 규칙을 어느정도 찾아서 구현하고 있는데 어우 어렵다..   
> 실패 - 실수로 7번째에 6660이 아니라 6000을 출력했다.   
> 실패 - 어디서 실패한건지 모르겠다. 오버플로우가 나서 그런가 해서 long long으로 바꿨는데 여전히 오답으로 나온다. 어디서 중복이 나는 경우를 고려하지 못한거같다.   

> https://st-lab.tistory.com/103    
찾아보니 브루트포스 알고리즘을 이용해서 문자열로 풀면 쉽게 풀 수 있는 문제인것 같다. 그리고 나처럼 int로 구간을 나눠서 푼 사람도 있어서 참고하려고 했는데 방식이 조금 달라서 내 방법으로 다시 첨부터 차근차근 해봤다.    

> 10000을 입력했을때 266799가 나와야하는데 2662666이 나오는걸보면 아무래도 중복해서 센 부분이 있는 것 같다.    
> 손으로 직접 써가면서 풀어봤는데 2860에서 원래 699666이 나와야되는데 이상한 값이 나오는것을 발견했다.    
> 계속 하면 할수록 예외 처리 해야되는게 새로 나와서 끝이 없다... 이문제에만 몇시간을 쓴건지 모르겠다.   

> 더 이상하는건 미련인 것 같아서 다른 사람의 코드를 참고해서 해결하기로 결정했다.   
그리고 앞으로도 문제를 해결할때는 한시간안에 못풀면 다른 사람의 코드를 참고하기로 결정했다.   


### 오늘의 교훈
> 알고리즘 문제를 풀때 어느정도 시간을 정해두고 정 안풀리면 다른 사람들 코드를 참고해서 공부하자.    
> 아직 모르는 알고리즘 개념도 많고 경험도 적어서 오래 고민하더라도 풀리지 않을 가능성이 높다. 그리고 그 시간에 다양한 문제를 풀어보는게 오히려 더 도움이 될 것 같다.   

> 어떤 블로그에서 알고리즘 문제 풀때 한문제를 너무 오래 붙잡고 있는것은 오히려 독이 된다고 시간을 정해두고 푸는 것이 좋다고 했는데 오늘 정말 뼈저리게 느낀다..    


[BOJ 2805 EXO](https://www.acmicpc.net/problem/2805)
> 성공. 중간에 자료형을 잘못써서 한번 틀리긴 했지만 그래도 최근에 분할 정복 문제를 많이 풀어봐서 그런가 수월하게 풀었다.

[BOJ 10989 수 정렬하기 3](https://www.acmicpc.net/problem/10989)
> 성공. 처음에 vector로 풀었다가 메모리 초과가 나서 map으로 다시 풀었다.

[BOJ 11651 좌표 정렬하기 2](https://www.acmicpc.net/problem/11651)
> 성공. 뭔가 꼼수인거 같기도 하지만 x랑 y 위치만 바꿔서 map이랑 pair 이용해서 풀었다.

[BOJ 1966 Printer Queue](https://www.acmicpc.net/problem/1966)
> 보류 - 조금 생각이 필요할 것 같다. 앞에 있는 우선순위가 낮은 수들을 뒤로 옮기는 과정에서 변동이 생겨서 단순히 우선순위큐를 써서 풀 수는 없는 것 같다.   
> 성공 - 큐에 우선순위와 인덱스를 저장해서 사용하고, 우선순위를 체크하기 위해서 크기 10짜리 벡터를 하나 만들어서 관리하는 방식으로 구현했다. 꽤 까다로웠다.

[BOJ 10773 Zero That Out](https://www.acmicpc.net/problem/10773)
> 성공. stack만 안다면 쉽게 풀 수 있는 문제인것 같다.

[BOJ 2108 통계학](https://www.acmicpc.net/problem/2108)
> 성공. 엄청 간단할 줄 알았는데 최빈값을 어떻게 구할지 생각이 잘 안나서 좀 힘들었다.

[BOJ 4949 The Balance of the World](https://www.acmicpc.net/problem/4949)
> 성공. 괄호 종류만 2개로 늘어나고 전에 풀어봤던 문제랑 비슷해서 수월하게 풀 수 있었다.

[BOJ 18111 마인크래프트](https://www.acmicpc.net/problem/18111)
> 성공. 28ms. map을 이용해서 풀었다.   
지금은 실버 정도 난이도가 나한테 잘 맞는 것 같다. 적당히 어려워서 고민을 좀 해야 풀리다보니 성취감도 느껴지고 좋다.

[BOJ 1874 스택 수열](https://www.acmicpc.net/problem/1874)
> 성공. 20ms. stack을 이용해서 직접 돌려보는 식으로 구현했다.

[BOJ 15353 큰 수 A+B(2)](https://www.acmicpc.net/problem/15353)
> 전에 이 문제를 푸느라 애먹었던 기억이 나서 다시 한번 풀어봤다.   
> 성공. 종만북에서 한번 풀어봐서 그런가 그래도 수월하게 풀었다.

[BOJ 7568 덩치](https://www.acmicpc.net/problem/7568)
> 성공. 입력의 크기가 작은걸 보고 O(n^2)으로 그냥 무식하게 풀어버려도 될 것 같아서 수월하게 풀었다.

### 브루트 포스 알고리즘 (종만북 - 무식하게 풀기)

모든 경우의 수를 탐색하는 알고리즘.     
대표적으로 순차 탐색, 깊이우선탐색(DFS), 너비우선탐색(BFS)을 사용한다.

문제 해결 방법
1. 주어진 문제를 선형 구조로 구조화한다.
2. 구조화된 문제공간을 적절한 방법으로 해를 구성할 때까지 탐색한다.
3. 구성된 해를 정리한다.

[BOJ 1436 영화감독 숌](https://www.acmicpc.net/problem/1436)     

브루트포스가 새로운 알고리즘인줄 알았는데 이미 종만북에서 봤었던 "무식하게 풀기"랑 이름만 다르고 내용은 같아서 그렇게 한번 풀어봤는데 아...? 그냥 무식하게 666부터 해당 숫자가 10000개가 나올때까지 for문 돌려서 배열에 저장해서 하니깐 성공했다.     
뭔가 좀 허무하긴 하지만 성공. solved.ac class 2++도 완료했다.    

[BOJ 9935 EXSPLOZIJA](https://www.acmicpc.net/problem/9935)     

작년에 시도해봤다가 못 풀었던 문제.      

메모리 초과. 입력되는 string의 길이도 긴데 재귀함수로 구현하면서 너무 많은 string을 사용해서 그런것같다.     
-> 검사 방식을 바꾸고 매개변수도 참조형으로 바꾸니깐 50%에서 메모리초과.      
-> 배열을 새로 만드는대신 erase 내장 함수 활용. 57%에서 시간초과.     
-> find랑 erase로 코드를 엄청 짧게 짤수있지만 2%에서 시간초과.        
-> stack을 활용해서 한번에 처리할 수 있지 않을까. 폭발물인지 검사하다가 끊겼는데 폭발물의 첫글자인경우는 이어서 셀 수 있다.     
-> Segfault. 폭발물이 중간에 끊겼을때 check를 0으로 초기화하지 않으면서 이상한 곳을 참조하면 오류가 났다.    
-> 시간초과. 아무래도 erase를 수행하면서 시간이 많이 걸리는것같다. erase대신 문자열을 deque에 저장해버리자.     
-> 성공. 36ms.    

[BOJ 9659 돌 게임 5](https://www.acmicpc.net/problem/9659)    

성공. 0ms. 규칙만 찾아낸다면 정말 쉬운 문제.    

[BOJ 1927 최소 힙](https://www.acmicpc.net/problem/1927)    

성공. priority_queue를 사용하면 쉽게 풀 수 있긴하다 (16ms)    

자료구조 복습겸 직접 heap을 구현.     

런타임에러(segfault).      

성공. 배열을 동적할당해서 썼다가 100000 크기 배열을 썼더니 성공했다.

### heap

    heap property(heap-order)를 만족하는 complete binary tree.
    
    heap property(heap-order)    
    : parent 노드가 child node보다 무조건 작다.

### solved.ac CLASS 3

[BOJ 11723 집합](https://www.acmicpc.net/problem/11723)

성공. 724ms. map을 이용해서 풀었다.

[BOJ 1003 피보나치 함수](https://www.acmicpc.net/problem/1003)

성공. n의 범위를 n<40으로 처음에 잘못 설정해서 틀렸다.

문제 자체는 일반적인 피보나치랑 크게 다르지 않아서 dp를 이용해서 쉽게 구현했다.

[BOJ 9095 Adding 1s, 2s, and 3s](https://www.acmicpc.net/problem/9095)

1,2,3만 사용하고 순서도 고려해야 되서 생각보다 까다롭다.

성공. nCr을 이용해서 풀었다.

```
3이 x개, 2가 y개, 1이 z개
배열하는 방법: (x+y+z)!/(x!y!z!)
```

[BOJ 11399 ATM](https://www.acmicpc.net/problem/11399)

성공. 굉장히 수월하게 풀었다. 먼저 돈을 뽑을수록 전체 소요시간에 영향을 많이 미치기 때문에 오름차순으로 정렬해서 풀면 된다.

[BOJ 1620 나는야 포켓몬 마스터 이다솜](https://www.acmicpc.net/problem/1620)

시간초과. O(n^2) 알고리즘을 사용하면 최대 10억이라 시간초과가 난다.

성공. vector랑 map을 사용해서 풀었다.

요새 골드를 주로 풀어서 그런가 실버 4,5 정도 문제는 큰 어려움이 없이 수월하게 풀린다.

[BOJ 1764 듣보잡](https://www.acmicpc.net/problem/1764)

map을 이용하면 쉽게 풀 수 있을 것 같다.

성공. 처음에 사전 순이라는 조건을 못보고 풀어서 틀렸다.

[BOJ 11726 2xn 타일링](https://www.acmicpc.net/problem/11726)

처음에는 2x1 타일 2개를 어디에 몇개나 배치할지 조합으로 풀려고 했는데 묶음끼리 한칸씩 떨어진 경우를 고려하지 못했다.

좀 더 고민을 해보니 피보나치랑 똑같은 문제라는걸 알게되었다.

앞에 1x2 타일이 오거나 2x1 타일 2개가 올 수 있는데 각각의 경우는 n-1, n-2만큼씩 있다.

성공.

[BOJ 11444 피보나치 수 6](https://www.acmicpc.net/problem/11444)

어렵군..

[BOJ 2630 색종이 만들기](https://www.acmicpc.net/problem/2630)

쪼개서 풀면 될거같다. 예를 들어 4칸 짜리 사각형은 1칸짜리 사각형으로 이루어져있다.

따라서 해당사각형을 이루고 있는 사각형이 모두 같은 색깔이면 1개. 그게 아니라면 해당 사각형을 이루고 있는 사각형들을 이루고 있는 사각형들의 개수의 합.

하지만 구현하는게 쉽지않다. 정리해서 써보고 코딩으로 구현하자.

1. 이미 다른 색으로 구성된 경우

   -> 고려 x

2. 같은 색으로 구성되어있지만 다른 사각형과 색이 같지 않은 경우

   -> 흰/파 개수 정산, 결과값에 반영 -> 1번 경우라는 것을 나타내기 위해 -1반환

3. 4개다 색이 동일한 경우

   -> 다음단계로 패스(사각형 한개로 취급). 0또는 1반환.

성공.

[BOJ 1012 유기농 배추](https://www.acmicpc.net/problem/1012)

왼쪽위에서 오른쪽 아래로 진행. 배추의 왼쪽이나 위에 배추가 없다면 새로운 집합으로 간주.

실패.

```
11
01
11
```

예제는 다 통과했지만 이런 예외 상황을 고려하지 못했다.

재귀함수처럼 구현하는 게 좋을것같다.

한 배추를 정해서 상하좌우를 탐색해서 방문하지 않은 배추 방문.

실패. 배열들의 값을 초기화해주지 않고 사용해서 오답이 나온것같다.

그리고 저번에도 이런 적이 있는데 범위를 잘못 지정해서 OutOfBounds 런타임 에러가 나왔다.

(n, m의 범위가 0부터 50까지인데 크기가 50*50인 배열을 사용했다.)

성공.

[BOJ 1931 회의실 배정](https://www.acmicpc.net/problem/1931)

LIS 문제랑 비슷한 거 같다.

O(n^2) 알고리즘을 사용했는데 입력의 크기가 10만이라 역시나 시간초과가 나온다.

일반적인 LIS와 달리 시작시간과 끝시간이 있어서 고려해야 하는 케이스가 좀 더 많아서 구현하기 까다로운 것 같다.

어떻게 최적화를 해야할까..

1. 오름차순으로 정렬(시작, 종료 시간 기준)
2. 회의 벡터에 저장
3. 벡터에 저장된 마지막 회의를 기준으로
   1. 종료시간이 더 작은 경우 -> 교체
   2. 시작시간이 종료시간보다 늦는 경우 -> 추가

성공.

[BOJ 11724 연결 요소의 개수](https://www.acmicpc.net/problem/11724)

BFS로 간단하게 풀 수 있을 것 같다. 성공.

[BOJ 18870 좌표 압축](https://www.acmicpc.net/problem/18870)

입력의 크기가 백만이라 O(n^2)으로 구현하면 시간초과가 나올 것 같은데 O(n^2)인 아닌 방법으로 어떻게 구해야할지 잘 모르겠다. 한번 제출해봤는데 역시나 시간초과.

입력받으면서 몇번째 숫자인지 업데이트 해나가는 방식은 O(n^2)이 아닌 방법으로 구현할 수 없는 것 같다.

정렬한 배열을 따로 저장해서 이진 탐색으로 몇번째 숫자인지 출력하면 O(nlogn)으로 구현할 수 있지 않을까

map을 이용해서 풀었다. 성공.

다른 사람의 풀이를 봤는데 어렴풋이 생각했던 방법이지만 구현하지 못했던 방법이었다.

(벡터에 좌표랑 인덱스를 같이 저장해서 정렬을 하고 맨 앞부터 차례대로 검사해서 숫자가 같으면 같은 순위를 사용하고 이외에는 순위를 점차 증겨시켜나가면서 크기가 n인 결과값을 저장할 배열의 해당 인덱스에 순위를 저장시킨뒤 출력.)

[BOJ 1074 Z](https://www.acmicpc.net/problem/1074)

while(n--)

0 + 2^(2\*n)\*(r/(2^n)\*2 + c/(2^n)) + ...

r%=(2^n)	c%=(2^n)

성공.

[BOJ 7576 토마토](https://www.acmicpc.net/problem/7576)

상자 최대 크기 1000,000

O(n^2) 알고리즘으로 구현하면 시간초과가 나올 것이다.

bfs로 풀면 될 것 같다. 입력받으면서 익은 토마토들 위치를 queue에 넣고 인접한 안 익은 토마토들 익은 토마토로 바꾸고 queue에 넣기.

성공.

### solved.ac CLASS 4

[BOJ 15650 N과 M(2)](https://www.acmicpc.net/problem/15650)

성공. 재귀함수로 쉽게 풀었다.

[BOJ 15652 N과 M (4)](https://www.acmicpc.net/problem/15652)

성공. BOJ 15650이랑 거의 똑같은 문제. 요즘 java를 공부중이라 연습삼아 java로 풀었다.

[BOJ 15654 N과 M (5)](https://www.acmicpc.net/problem/15654)

성공.

[BOJ 15657 N과 M(8)](https://www.acmicpc.net/problem/15657)

성공.

[BOJ 2407 조합](https://www.acmicpc.net/problem/2407)

일반적인 방법으로 구현하면 8byte 자료형을 쓰더라도 overflow가 생긴다.

최대값인 100C50의 경우 결과값도 8byte를 넘어가버린다.

문자열을 이용해서 계산해야 할 것 같은데 나눗셈은 어떻게 계산해야할지 감이 잘 안잡힌다.



### Codefoces Round #739 (Div. 3)

[D, Make a Power of Two](https://codeforces.com/contest/1560/problem/D)

2의 제곱들과 앞자리수부터 비교

> ex) 1052
>
> 1024중에서 102까지 겹친다.
>
> 4-3+(4-3) = 2
>
> ex) 888
>
> 8중에서 모든 자리가 겹친다.3-1 = 2

384와 같은 경우 3자리 숫자지만 5자리 숫자인 16384에서 최소값 2를 갖는다.

> -> 1자리 숫자인 4나 8에서도 최소값 2를 갖는다.
>
> n자리 숫자인 경우 n자리 2의 제곱수 까지만 확인해보면 될것같다.
>
> -> 6인 경우 1자리 숫자지만 2자리 숫자인 64가 최소값 1을 갖는다.

그래서 자리수 상관없이 모두 돌려봤는데 test case 4에서 오답이 나온다.

해설지를 참고해서 풀었다.

최악의 경우 맨 끝자리에 1을 붙이고 나머지 자릿수를 다 삭제하면 2의 제곱이므로 n자리수의 경우 결과값은 최대 n+1이다. 따라서 n자리수의 경우 2n자리수까지만 고려해주면 된다.

2제곱 배열을 10^18까지 저장하도록 변경했더니 맞았다.

bruteforce 알고리즘. 언뜻보면 n이 최대 10^9라 시간복잡도가 커보이지만 문자열로 저장해서 각 자리수만 검사하기 때문에 시간복잡도가 크지 않다.

거의 다 맞은거였는데 조금 아쉽다.

