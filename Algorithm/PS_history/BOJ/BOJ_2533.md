# [백준] 사회망 서비스(SNS)

Gold 3

https://www.acmicpc.net/problem/2533

<br>

## 실패

친구가 많은 사람부터 방문하고, 방문할때마다 해당 사람 친구들의 친구 수를 1 감소시켜서 모든 사람들의 친구 수가 0이 될때까지 반복하는 식으로 풀었다.

어떻게 친구 수를 update해야 시간초과가 나지 않을까 고민하다가 update 횟수를 저장해두고 방문할때 update된 횟수가 0이면 방문하고, 그렇지 않는다면 다시 PriorityQueue에 넣는 식으로 구현했다.

하지만 4%에서 오답이 나왔다.

> 시간 초과가 나올 수 있지 않을까라는 생각은 했었는데 왜 오답이 나왔는지 이유를 모르겠다.

백준 `질문 검색` 게시판에서 반례를 좀 찾아봤는데 통과하지 않는 반례가 없었다...

> tree dp로 풀어야한다는 게시글을 보긴 했는데 그래도 왜 내 소스코드가 정답이 나오지 않는지는 이해가 되지 않는다.

<details><summary>소스코드</summary>

```java
import java.io.*;
import java.util.*;

class Human implements Comparable<Human> {
    public int num, friendsCnt;

    public Human(int num, int friendsCnt) {
        this.num = num;
        this.friendsCnt = friendsCnt;
    }

    @Override
    public int compareTo(Human o) {
        return o.friendsCnt - this.friendsCnt;
    }
}

class Main {

    int N;
    List<List<Integer>> friends;
    int[] updateCnt;
    boolean[] isEarlyAdopter;
    PriorityQueue<Human> pq;

    final int INF = 987654321;

    int answer() {
        int earlyAdopterCnt = 0;

        while (!pq.isEmpty()) {
            Human earlyAdopterCandidate = pq.poll();
            if(earlyAdopterCandidate.friendsCnt == 0) break;

            if(isEarlyAdopter[earlyAdopterCandidate.num]) continue;

            if(updateCnt[earlyAdopterCandidate.num] > 0) {
                pq.add(new Human(earlyAdopterCandidate.num, earlyAdopterCandidate.friendsCnt - updateCnt[earlyAdopterCandidate.num]));
                updateCnt[earlyAdopterCandidate.num] = 0;
                continue;
            }

            isEarlyAdopter[earlyAdopterCandidate.num] = true;
            earlyAdopterCnt++;
            for (int friend : friends.get(earlyAdopterCandidate.num)) {
                if(isEarlyAdopter[friend]) continue;
                updateCnt[friend]++;
            }
        }
        return earlyAdopterCnt;
    }

    void solution() throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();

        N = Integer.parseInt(br.readLine());
        friends = new ArrayList<>();
        for (int i = 0; i < N; i++) {
            friends.add(new ArrayList<>());
        }
        for (int i = 0; i < N - 1; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int u = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            u--; v--;
            friends.get(u).add(v);
            friends.get(v).add(u);
        }

        updateCnt = new int[N];
        Arrays.fill(updateCnt, 0);
        isEarlyAdopter = new boolean[N];
        Arrays.fill(isEarlyAdopter, false);
        pq = new PriorityQueue<>();
        for (int i = 0; i < N; i++) {
            pq.add(new Human(i, friends.get(i).size()));
        }

        System.out.println(answer());
        br.close();
    }

    public static void main(String[] args) throws Exception {
        new Main().solution();
    }
}
```

</details><br>

우선 tree dp를 통해서 풀어보고 테스트 데이터를 만들어서 반례를 직접 찾아봐야겠다.

* child 배열을 따로 구하는 일반적인 TOP-DOWN 방식의 풀이

  https://www.weeklyps.com/entry/BOJ-2533-%EC%82%AC%ED%9A%8C%EB%A7%9D-%EC%84%9C%EB%B9%84%EC%8A%A4

* dfs + dp

  https://maivve.tistory.com/322

실수로 dp 배열 크기를 N * N으로 했다가 메모리 초과가 나와서 한참 헤맸다.

> 어..? 블로그랑 분명 동일한 풀인데..?

<br>